import pointers.*;
import curl.h.*;

record CurlException (operation: StringConstant, message: CStringRef);

overload printTo(stream, ce: CurlException) {
    printTo(stream, CurlException, ": failed to call ", ce.operation, ": ", ce.message);
}

instance Exception (CurlException);

private alias WriteFunction = Lambda[[Pointer[Char], SizeT], [SizeT]];
private alias HeaderFunction = WriteFunction;

record Curl (
    curl: Pointer[CURL],
    writeFunction: WriteFunction,
    headerFunction: HeaderFunction,
);

overload RegularRecord?(static Curl) = false;

overload Curl() {
    var curlCurl = curl_easy_init();
    if (null?(curlCurl)) {
        throw CurlException("curl_easy_init", CStringRef(cstring("failed to initialize curl_easy")));
    }
    return Curl(curlCurl, WriteFunction(), HeaderFunction());
}

overload destroy(curl: Curl) {
    curl_easy_cleanup(curl.curl);
}


curlEasyReset(curl: Curl) {
    curl_easy_reset(curl.curl);
    curl.writeFunction = WriteFunction();
    curl.headerFunction = HeaderFunction();
}


[Code | CCodePointer?(Code)]
private callHandleError(code: Code, op: StringConstant, ..args) {
    var r = call(code, ..args);
    if (r != CURLE_OK) {
        throw CurlException(op, CStringRef(curl_easy_strerror(r)));
    }
}

private define curlEasySetoptParamConvert(p);

[L | Integer?(L) or L == Bool]
overload curlEasySetoptParamConvert(l: L) = CLong(l);
overload curlEasySetoptParamConvert(s: StringConstant) = cstring(s);
[T]
overload curlEasySetoptParamConvert(p: Pointer[T]) = p;
[C | CCodePointer?(C)]
overload curlEasySetoptParamConvert(c: C) = c;

curlEasySetopt(curl: Curl, opt, value) {
    callHandleError(curl_easy_setopt, "curl_easy_setopt", curl.curl, opt, curlEasySetoptParamConvert(value));
}

curlEasySetVerbose(curl: Curl, verbose: Bool) =
    ..curlEasySetopt(curl, CURLOPT_VERBOSE, verbose);

curlEasySetFailOnError(curl: Curl, fail: Bool) =
    ..curlEasySetopt(curl, CURLOPT_FAILONERROR, fail);

private writeFunctionTrampoline(ptr: Pointer[CChar], size: SizeT, nmemb: SizeT, userData: OpaquePointer): SizeT {
    var curl = Pointer[Curl](userData);
    return curl^.writeFunction(Pointer[Char](ptr), size * nmemb);
}

curlEasySetWriteFunction(curl, writeFunction) {
    curl.writeFunction = WriteFunction(writeFunction);
    
    var trampolinePointer = makeCCodePointer(writeFunctionTrampoline, Pointer[CChar], SizeT, SizeT, OpaquePointer);
    curlEasySetopt(curl, CURLOPT_FILE, &curl);
    curlEasySetopt(curl, CURLOPT_WRITEFUNCTION, trampolinePointer);
}

curlEasySetWriteToDevNull(curl) =
    ..curlEasySetWriteFunction(curl, (data, size) -> size);

curlEasySetWriteTo(curl, ref stream) =
    ..curlEasySetWriteFunction(curl, (data, size) -> {
        printTo(stream, CoordinateRange(data, data + size)); return size;
    });

private headerFunctionTrampoline(ptr: Pointer[CChar], size: SizeT, nmemb: SizeT, userData: OpaquePointer): SizeT {
    var curl = Pointer[Curl](userData);
    return curl^.headerFunction(Pointer[Char](ptr), size * nmemb);
}

curlEasySetHeaderFunction(curl, headerFunction) {
    curl.headerFunction = HeaderFunction(headerFunction);
    
    var trampolinePointer = makeCCodePointer(headerFunctionTrampoline, Pointer[CChar], SizeT, SizeT, OpaquePointer);
    curlEasySetopt(curl, CURLOPT_WRITEHEADER, &curl);
    curlEasySetopt(curl, CURLOPT_HEADERFUNCTION, trampolinePointer);
}

curlEasySetUrl(curl, url) =
    ..curlEasySetopt(curl, CURLOPT_URL, url);

curlEasySetUserAgent(curl, userAgent) =
    ..curlEasySetopt(curl, CURLOPT_USERAGENT, userAgent);

curlEasyPerform(curl: Curl) {
    callHandleError(curl_easy_perform, "curl_easy_perform", curl.curl);
}

[Type]
private curlEasyGetInfoImpl(curl: Curl, info, static Type) {
    // TODO: do not initialize
    var r = Type();
    callHandleError(curl_easy_getinfo, "curl_easy_getinfo", curl.curl, info, &r);
    return r;
}

curlEasyGetInfoLong(curl: Curl, info) =
    curlEasyGetInfoImpl(curl, info, CLong);

curlEasyGetInfoCString(curl: Curl, info) =
    curlEasyGetInfoImpl(curl, info, CStringRef);

curlEasyGetInfoDouble(curl: Curl, info) =
    curlEasyGetInfoImpl(curl, info, CDouble);

curlEasyGetResponseCode(curl) =
    Int(curlEasyGetInfoLong(curl, CURLINFO_RESPONSE_CODE));


curlEasyEscape(curl: Curl, url) {
    var r = curl_easy_escape(curl.curl, cstring(url), 0);
    finally curl_free(OpaquePointer(r));
    return String(r);
}

curlEasyUnescape(curl: Curl, url) {
    var r = curl_easy_unescape(curl.curl, cstring(url), 0, null(Int));
    finally curl_free(OpaquePointer(r));
    return String(r);
}


curlVersion() = CStringRef(curl_version());
